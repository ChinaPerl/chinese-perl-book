
=head1 NAME

Book::Chinese::DBIx-Class - DBIx-Class ORM

=head1 DESCRIPTION

本章主要描述如何组织你的 L<DBIx::Class> ORM 的结构和一些用法。

=head2 声明

=over 4

=item *

L<DBIx::Class> 是和 L<Catalyst> 分开, 二者是各自独立的。只是他们的作者之间有交集。

=item *

L<DBIx::Class> 不是为了性能而开发的。如果你的代码强烈要求性能的话，不建议你使用 DBIx::Class

=item *

如果你觉得 DBIx::Class 很难用，这可能有两个原因，一是你用错了，二是它不是你喜欢的类型。

=back

=head2 例子

本章将参考 L<TheSchwartz::Moosified> 的 schema/SQLite.sql 作为 database schema. （请参考 eg/DBIx-Class/schema.sql）

=over 4

=item * db.sqlite

第一步你需要创建一个 database, 定义好你的 schema. 例如：

    E:\Fayland\chinese-perl-book\eg\DBIx-Class>perl create_sqlite_db.pl

=item * 初始化 DBIx::Class

这里有两种方式可供选择，一种是手工编写所有的 DBIx::Class pm, 另一种是使用 L<DBIx::Class::Schema::Loader> 全自动生成

通常我会在第一次使用 L<DBIx::Class::Schema::Loader> 的 make_schema_at 来生成，而在以后就手工增加和修改 pm 或再次 make_schema_at

eg/DBIx-Class/make_schema_at.pl

    use FindBin qw/$Bin/;
    use DBIx::Class::Schema::Loader qw/ make_schema_at /;
    
    my $dbname = "$Bin/db.sqlite";
    make_schema_at(
        'TheSchwartz::Schema',
        { debug => 1, dump_directory => './lib' },
        [ "dbi:SQLite:dbname=$dbname" ],
    );

=item * 修改

DBIx::Class::Schema::Loader v0.04006 创建 schema 的时候是用了 load_classes

而从 DBIx::Class 0.081 开始，一个更推荐的做法是 L<http://search.cpan.org/dist/DBIx-Class/lib/DBIx/Class/Schema.pm#load_namespaces|load_namespaces>

不排除以后 Loader 会改为 load_namespaces. 所以以下修改可能很快就过期。

将 TheSchwartz::Schema 里的 load_classes 改为 load_namespaces, 将 lib/TheSchwartz/Schema/*.pm 移动到 
lib/TheSchwartz/Schema/Result/*.pm 并修改 package 增加 Result::

load_namespaces 将从 TheSchwartz::Schema::Result 下载入模块，从 TheSchwartz::Schema::ResultSet 下载入 ResultSet 模块

=item * 编写 load.t

为了验证所修改的是正确的，我们将使用一个 eg/DBIx-Class/t/00-load.t 文件来测试。

    #!/usr/bin/perl
    
    use strict;
    use warnings;
    use Test::More tests => 1;
    
    use_ok('TheSchwartz::Schema');
    
    1;

运行 prove 来测试

    E:\Fayland\chinese-perl-book\eg\DBIx-Class>prove -l t/
    t\00-load.t .. ok
    All tests successful.
    Files=1, Tests=1,  2 wallclock secs ( 0.05 usr +  0.02 sys =  0.06 CPU)
    Result: PASS

测试的重要性是再说一百次都不会过分。本章将从头到尾贯穿着不同的测试来验证自己所写的代码是自己所需的。

如何编写测试将在 L<BeACPANAuthor> 中做简单介绍

=item * 更多的测试代码

仅仅使用 use_ok 是验证代码是否有语法错误。而我们从上面的测试中无法知道具体的位置移动到底对不对。

eg/DBIx-Class/t/01-basic.t

    #!/usr/bin/perl
    
    use strict;
    use warnings;
    use Test::More tests => 5;
    use FindBin qw/$Bin/;
    use TheSchwartz::Schema;
    
    my $dbname = "$Bin/../db.sqlite";
    my $schema = TheSchwartz::Schema->connect(
        "dbi:SQLite:dbname=$dbname", '', '', {
        RaiseError => 1,
        PrintError => 0,
    } );
    isa_ok($schema, 'TheSchwartz::Schema');
    
    foreach ('Exitstatus', 'Job', 'Error', 'Funcmap') {
        can_ok( $schema->resultset($_), 'search' );
    }
    
    1;

在这里我们创建了 TheSchwartz::Schema 的实例，用 ->connect 方法。然后判断了 4 个 resultset 都能使用 search 方法 (L<DBIx::Class::ResultSet> 提供)，最后我们运行 prove

    E:\Fayland\chinese-perl-book\eg\DBIx-Class>prove -l t/
    t\00-load.t ... ok
    t\01-basic.t .. ok
    All tests successful.
    Files=2, Tests=10,  1 wallclock secs ( 0.05 usr +  0.05 sys =  0.09 CPU)
    Result: PASS

=item * ResultSet



=back

=head1 AUTHOR

Fayland Lam, C<< <fayland at gmail.com> >>

=head1 COPYRIGHT & LICENSE

This program is free software; you can redistribute it and/or modify it
under the same terms as Perl itself.
